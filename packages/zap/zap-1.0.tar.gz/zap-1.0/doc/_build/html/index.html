<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Welcome to ZAP’s documentation! &mdash; zap 1.0 documentation</title>
    
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="zap 1.0 documentation" href="#" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li><a href="#">zap 1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="welcome-to-zap-s-documentation">
<h1>Welcome to ZAP&#8217;s documentation!<a class="headerlink" href="#welcome-to-zap-s-documentation" title="Permalink to this headline">¶</a></h1>
<div class="toctree-wrapper compound">
<ul class="simple">
</ul>
</div>
<p>ZAP (the Zurich Atmosphere Purge) is a high precision sky subtraction tool which can be used as complete sky subtraction solution, or as an enhancement to previously sky-subtracted MUSE integral field spectroscopic data.  The method uses PCA to isolate the residual sky subtraction features and remove them from the observed datacube. Though the operation of ZAP is not dependent on perfect flatfielding of the data in a MUSE exposure, better results are obtained when these corrections are made ahead of time. Future development will include expansion to more instruments.</p>
</div>
<div class="section" id="installation">
<h1>Installation<a class="headerlink" href="#installation" title="Permalink to this headline">¶</a></h1>
<div class="section" id="requirements">
<h2>Requirements<a class="headerlink" href="#requirements" title="Permalink to this headline">¶</a></h2>
<p>ZAP requires the following packages:</p>
<ul class="simple">
<li>Numpy 1.6.0 or later</li>
<li>Astropy v1.0 or later</li>
<li>SciPy v0.13.3 or later</li>
</ul>
<p>Many linear algebra operations are performed in ZAP, so it can be beneficial to use an alternative BLAS package. In the Anaconda distribution, the default BLAS comes with Numpy linked to OpenBlas, which can amount to a 20% speedup of ZAP.</p>
</div>
<div class="section" id="steps">
<h2>Steps<a class="headerlink" href="#steps" title="Permalink to this headline">¶</a></h2>
<dl class="docutils">
<dt>ZAP can be installed using pip ::</dt>
<dd>pip install zap</dd>
</dl>
</div>
</div>
<div class="section" id="examples">
<h1>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h1>
<p>In its most hands-off form, ZAP can take an input fits datacube, operate on it, and output a final fits datacube:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">zap</span>
<span class="n">zap</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="s">&#39;INPUT.fits&#39;</span><span class="p">,</span> <span class="n">outcubefits</span><span class="o">=</span><span class="s">&#39;OUTPUT.fits&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Care should be taken, however, since this case assumes a sparse field, and better results can be obtained by applying masks.</p>
<p>The main function is <tt class="docutils literal"><span class="pre">zap.process</span></tt>:</p>
<p>There are a number of options that can be passed to the code which we describe here:</p>
<dl class="function">
<dt id="zap.process">
<tt class="descclassname">zap.</tt><tt class="descname">process</tt><big>(</big><em>musecubefits</em>, <em>outcubefits='DATACUBE_ZAP.fits'</em>, <em>clean=True</em>, <em>zlevel='median'</em>, <em>cftype='weight'</em>, <em>cfwidthSVD=100</em>, <em>cfwidthSP=50</em>, <em>pevals=[]</em>, <em>nevals=[]</em>, <em>optimizeType='normal'</em>, <em>extSVD=None</em>, <em>skycubefits=None</em>, <em>svdoutputfits='ZAP_SVD.fits'</em>, <em>mask=None</em>, <em>interactive=False</em><big>)</big><a class="headerlink" href="#zap.process" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs the entire ZAP sky subtraction algorithm.</p>
<p>Work on an input FITS file and optionally writes the product to an output
FITS file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>musecubefits</strong> : str</p>
<blockquote>
<div><p>Input FITS file, containing a cube with data in the first extension.</p>
</div></blockquote>
<p><strong>outcubefits</strong> : str</p>
<blockquote>
<div><p>Output FITS file, based on the input one to propagate all header
information and other extensions. Default to <cite>DATACUBE_ZAP.fits</cite>.</p>
</div></blockquote>
<p><strong>clean</strong> : bool</p>
<blockquote>
<div><p>If True (default value), the NaN values are cleaned. Spaxels with more
then 25% of NaN values are removed, the others are replaced with an
interpolation from the neighbors. The NaN values are reinserted into
the final datacube. If set to False, any spaxel with a NaN value will
be ignored.</p>
</div></blockquote>
<p><strong>zlevel</strong> : str</p>
<blockquote>
<div><p>Method for the zeroth order sky removal: <cite>none</cite>, <cite>sigclip</cite> or <cite>median</cite>
(default).</p>
</div></blockquote>
<p><strong>cftype</strong> : str</p>
<blockquote>
<div><p>Method for the continuum filter: <cite>median</cite> or <cite>weight</cite> (default). For
the <cite>weight</cite> method, a zeroth order sky is required (see <cite>zlevel</cite>).</p>
</div></blockquote>
<p><strong>cfwidthSVD</strong> : int or float</p>
<blockquote>
<div><p>Window size for the continuum filter, for the SVD computation.
Default to 100.</p>
</div></blockquote>
<p><strong>cfwidthSP</strong> : int or float</p>
<blockquote>
<div><p>Window size for the continuum filter used to remove the continuum
features for calculating the eigenvalues per spectrum. Smaller values
better trace the sources. An optimal range of is typically
20 - 50 pixels. Default to 50.</p>
</div></blockquote>
<p><strong>optimizeType</strong> : str</p>
<blockquote>
<div><p>Optimization method to compute the number of eigenspectra used for each
segment: <cite>none</cite>, <cite>normal</cite> (default), <cite>enhanced</cite>. If <cite>none</cite>, the number
of eigenspectra must be specified with <cite>nevals</cite> or <cite>pevals</cite>, otherwise
<cite>normal</cite> is used.</p>
</div></blockquote>
<p><strong>pevals</strong> : list</p>
<blockquote>
<div><p>Allow to specify the percentage of eigenspectra used for each segment.
If this is used, the pevals is ignored. Provide either a single value
that will be used for all of the segments, or a list of 11 values that
will be used for each of the segments.</p>
</div></blockquote>
<p><strong>nevals</strong> : list</p>
<blockquote>
<div><p>Allow to specify the number of eigenspectra used for each segment.
If this is used, the pevals is ignored. Provide either a single value
that will be used for all of the segments, or a list of 11 values that
will be used for each of the segments.</p>
</div></blockquote>
<p><strong>extSVD</strong> : str</p>
<blockquote>
<div><p>Path of an input FITS file containing a SVD computed by the
<a class="reference internal" href="#zap.SVDoutput" title="zap.SVDoutput"><tt class="xref py py-func docutils literal"><span class="pre">SVDoutput()</span></tt></a> function. Otherwise the SVD is computed.</p>
</div></blockquote>
<p><strong>skycubefits</strong> : str</p>
<blockquote>
<div><p>Path for the optional output of the sky that is subtracted from the
cube. This is simply the input cube minus the output cube.</p>
</div></blockquote>
<p><strong>svdoutputfits</strong> : str</p>
<blockquote>
<div><p>Output FITS file containing the eigenbasis. Default to <cite>ZAP_SVD.fits</cite>.</p>
</div></blockquote>
<p><strong>mask</strong> : str</p>
<blockquote>
<div><p>A 2D fits image to exclude regions that may contaminate the zlevel or
eigenspectra. This image should be constructed from the datacube itself
to match the dimensionality. Sky regions should be marked as 0, and
astronomical sources should be identified with an integer greater than
or equal to 1. Default to None.</p>
</div></blockquote>
<p><strong>interactive</strong> : bool</p>
<blockquote class="last">
<div><p>If True, a <a class="reference internal" href="#zap.zclass" title="zap.zclass"><tt class="xref py py-class docutils literal"><span class="pre">zclass</span></tt></a> object containing all information on
the ZAP process is returned, and can be used to explore the
eigenspectra and recompute the output (with the
<a class="reference internal" href="#zap.zclass.reprocess" title="zap.zclass.reprocess"><tt class="xref py py-meth docutils literal"><span class="pre">reprocess()</span></tt></a> method). In this case, the output files
are not saved (<cite>outcubefits</cite> and <cite>skycubefits</cite> are ignored). Default to
False.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The code can handle datacubes trimmed in wavelength space. Since the code uses the correlation of segments of the emission line spectrum, it is best to trim the cube at specific wavelengths. The cube can include any connected subset of these segments. (for example 6400 - 8200 Angstroms)</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="mi">0</span><span class="p">,</span>    <span class="mi">5400</span><span class="p">]</span>
<span class="p">[</span><span class="mi">5400</span><span class="p">,</span> <span class="mi">5850</span><span class="p">]</span>
<span class="p">[</span><span class="mi">5850</span><span class="p">,</span> <span class="mi">6440</span><span class="p">]</span>
<span class="p">[</span><span class="mi">6440</span><span class="p">,</span> <span class="mi">6750</span><span class="p">]</span>
<span class="p">[</span><span class="mi">6750</span><span class="p">,</span> <span class="mi">7200</span><span class="p">]</span>
<span class="p">[</span><span class="mi">7200</span><span class="p">,</span> <span class="mi">7700</span><span class="p">]</span>
<span class="p">[</span><span class="mi">7700</span><span class="p">,</span> <span class="mi">8265</span><span class="p">]</span>
<span class="p">[</span><span class="mi">8265</span><span class="p">,</span> <span class="mi">8602</span><span class="p">]</span>
<span class="p">[</span><span class="mi">8602</span><span class="p">,</span> <span class="mi">8731</span><span class="p">]</span>
<span class="p">[</span><span class="mi">8731</span><span class="p">,</span> <span class="mi">9275</span><span class="p">]</span>
<span class="p">[</span><span class="mi">9275</span><span class="p">,</span> <span class="mi">10000</span><span class="p">]</span>
</pre></div>
</div>
<div class="section" id="sparse-field-case">
<h2>Sparse Field Case<a class="headerlink" href="#sparse-field-case" title="Permalink to this headline">¶</a></h2>
<p>This case specifically refers to the case where the sky can be measured in the sky frame itself, using:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">zap</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="s">&#39;INPUT.fits&#39;</span><span class="p">,</span> <span class="n">outcubefits</span><span class="o">=</span><span class="s">&#39;OUTPUT.fits&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>In both cases, the code will create a resulting processed datacube named <tt class="docutils literal"><span class="pre">DATACUBE_ZAP.fits</span></tt> and an SVD file named <tt class="docutils literal"><span class="pre">ZAP_SVD.fits</span></tt> in the current directory. While this can work well in the case of very faint sources, masks can improve the results.</p>
<p>For the sparse field case, a mask file can be included, which is a 2d fits image matching the spatial dimensions of the input datacube. Masks are defined to be &gt;= 1 on astronomical sources and 0 at the position of the sky. Set this parameter with the <tt class="docutils literal"><span class="pre">mask</span></tt> keyword</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">zap</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="s">&#39;INPUT.fits&#39;</span><span class="p">,</span> <span class="n">outcubefits</span><span class="o">=</span><span class="s">&#39;OUTPUT.fits&#39;</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="s">&#39;mask.fits&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="filled-field-case">
<h2>Filled Field Case<a class="headerlink" href="#filled-field-case" title="Permalink to this headline">¶</a></h2>
<p>This approach also can address the saturated field case and is robust in the case of strong emission lines, in this case the input is an offset sky observation. To achieve this, we calculate the SVD on an external sky frame using the function <tt class="docutils literal"><span class="pre">zap.SVDoutput</span></tt></p>
<dl class="function">
<dt id="zap.SVDoutput">
<tt class="descclassname">zap.</tt><tt class="descname">SVDoutput</tt><big>(</big><em>musecubefits</em>, <em>svdoutputfits='ZAP_SVD.fits'</em>, <em>clean=True</em>, <em>zlevel='median'</em>, <em>cftype='weight'</em>, <em>cfwidth=100</em>, <em>mask=None</em><big>)</big><a class="headerlink" href="#zap.SVDoutput" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs the SVD decomposition of a datacube.</p>
<p>This allows to use the SVD for a different datacube.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>musecubefits</strong> : str</p>
<blockquote>
<div><p>Input FITS file, containing a cube with data in the first extension.</p>
</div></blockquote>
<p><strong>svdoutputfits</strong> : str</p>
<blockquote>
<div><p>Output FITS file. Default to ZAP_SVD.fits</p>
</div></blockquote>
<p><strong>clean</strong> : bool</p>
<blockquote>
<div><p>If True (default value), the NaN values are cleaned. Spaxels with more
then 25% of NaN values are removed, the others are replaced with an
interpolation from the neighbors.</p>
</div></blockquote>
<p><strong>zlevel</strong> : str</p>
<blockquote>
<div><p>Method for the zeroth order sky removal: <cite>none</cite>, <cite>sigclip</cite> or <cite>median</cite>
(default).</p>
</div></blockquote>
<p><strong>cftype</strong> : str</p>
<blockquote>
<div><p>Method for the continuum filter: <cite>median</cite> or <cite>weight</cite> (default). For
the <cite>weight</cite> method, a zeroth order sky is required (see <cite>zlevel</cite>).</p>
</div></blockquote>
<p><strong>cfwidth</strong> : int or float</p>
<blockquote>
<div><p>Window size for the continuum filter, default to 300.</p>
</div></blockquote>
<p><strong>mask</strong> : str</p>
<blockquote class="last">
<div><p>Path of a FITS file containing a mask (1 for objects, 0 for sky).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>An example of running the code in this way is as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">zap</span><span class="o">.</span><span class="n">SVDoutput</span><span class="p">(</span><span class="s">&#39;Offset_Field_CUBE.fits&#39;</span><span class="p">,</span> <span class="n">svdfn</span><span class="o">=</span><span class="s">&#39;ZAP_SVD.fits&#39;</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="s">&#39;mask.fits&#39;</span><span class="p">)</span>
<span class="n">zap</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="s">&#39;Source_cube.fits&#39;</span><span class="p">,</span> <span class="n">outcubefits</span><span class="o">=</span><span class="s">&#39;OUTPUT.fits&#39;</span><span class="p">,</span> <span class="n">extSVD</span><span class="o">=</span><span class="s">&#39;ZAP_SVD.fits&#39;</span><span class="p">,</span> <span class="n">cfwidthSP</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
</pre></div>
</div>
<p>The integration time of this frame does not need to be the same as the object exposure, but rather just a 2-3 minute exposure. Often residuals can be further reduced by changing <cite>cfwidthSP</cite> to a smaller value. However, this parameter should not be reduced to smaller than 15 pixels.</p>
</div>
</div>
<div class="section" id="extra-functions">
<h1>Extra Functions<a class="headerlink" href="#extra-functions" title="Permalink to this headline">¶</a></h1>
<p>Aside from the main process, two functions are included that can be run outside of the entire zap process to facilitate some investigations.</p>
<dl class="function">
<dt id="zap.nancleanfits">
<tt class="descclassname">zap.</tt><tt class="descname">nancleanfits</tt><big>(</big><em>musecubefits</em>, <em>outfn='NANCLEAN_CUBE.fits'</em>, <em>rejectratio=0.25</em>, <em>boxsz=1</em><big>)</big><a class="headerlink" href="#zap.nancleanfits" title="Permalink to this definition">¶</a></dt>
<dd><p>Detects NaN values in cube and removes them by replacing them with an
interpolation of the nearest neighbors in the data cube. The positions in
the cube are retained in nancube for later remasking.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>musecubefits</strong> : str</p>
<blockquote>
<div><p>Input FITS file, containing a cube with data in the first extension.</p>
</div></blockquote>
<p><strong>outfn</strong> : str</p>
<blockquote>
<div><p>Output FITS file. Default to NANCLEAN_CUBE.fits</p>
</div></blockquote>
<p><strong>rejectratio</strong> : float</p>
<blockquote>
<div><dl class="docutils">
<dt>Defines a cutoff for the ratio of NAN to total pixels in a spaxel</dt>
<dd><p class="first last">before the spaxel is avoided completely. Default to 0.25</p>
</dd>
</dl>
</div></blockquote>
<p><strong>boxsz</strong> : int</p>
<blockquote class="last">
<div><p>Defines the number of pixels around the offending NaN pixel.
Default to 1, which looks for the 26 nearest neighbors which
is a 3x3x3 cube.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="zap.wmedian">
<tt class="descclassname">zap.</tt><tt class="descname">wmedian</tt><big>(</big><em>spec</em>, <em>wt</em>, <em>cfwidth=100</em><big>)</big><a class="headerlink" href="#zap.wmedian" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs a weighted median filtering of a 1d spectrum</p>
<p>Operates using a cumulative sum curve</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>spec</strong> : numpy.ndarray</p>
<blockquote>
<div><p>Input 1d spectrum to be filtered</p>
</div></blockquote>
<p><strong>wt</strong> : numpy.ndarray</p>
<blockquote>
<div><p>A spectrum of equal length as the input array to provide the weights.</p>
</div></blockquote>
<p><strong>cfwidth</strong> : int or float</p>
<blockquote class="last">
<div><p>Window size for the continuum filter, for the SVD computation.
Default to 100.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="command-line-interface">
<h1>Command Line Interface<a class="headerlink" href="#command-line-interface" title="Permalink to this headline">¶</a></h1>
<p>ZAP can also be used from the command line:</p>
<div class="highlight-python"><div class="highlight"><pre>python -m zap INPUT_CUBE.fits
</pre></div>
</div>
<p>More information use of the command line interface can be found with the command</p>
<div class="highlight-python"><div class="highlight"><pre>python -m zap -h
</pre></div>
</div>
</div>
<div class="section" id="interactive-mode">
<h1>Interactive mode<a class="headerlink" href="#interactive-mode" title="Permalink to this headline">¶</a></h1>
<p>ZAP can also  be used interactively from within IPython</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">zap</span>
<span class="n">zobj</span> <span class="o">=</span> <span class="n">zap</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="s">&#39;INPUT.fits&#39;</span><span class="p">,</span> <span class="n">interactive</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>The run method operates on the datacube, and retains all of the data and
methods necessary to process a final data cube in a python class named
<a class="reference internal" href="#zap.zclass" title="zap.zclass"><tt class="xref py py-class docutils literal"><span class="pre">zclass</span></tt></a>. You can elect to investigate the data product via the
<a class="reference internal" href="#zap.zclass" title="zap.zclass"><tt class="xref py py-class docutils literal"><span class="pre">zclass</span></tt></a>, and even reprocess the cube with a different number of
eigenspectra per region.  A workflow may go as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">zap</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="c"># allow ZAP to run the optimize routine</span>
<span class="n">zobj</span> <span class="o">=</span> <span class="n">zap</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="s">&#39;INPUT.fits&#39;</span><span class="p">,</span> <span class="n">optimization</span><span class="o">=</span><span class="s">&#39;normal&#39;</span><span class="p">,</span> <span class="n">interactive</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="c"># plot the variance curves and the selection of the number of eigenspectra used</span>
<span class="n">zobj</span><span class="o">.</span><span class="n">plotvarcurve</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>

<span class="c"># plot a spectrum extracted from the original cube</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">zobj</span><span class="o">.</span><span class="n">cube</span><span class="p">[:,</span><span class="mi">50</span><span class="p">:</span><span class="mi">100</span><span class="p">,</span><span class="mi">50</span><span class="p">:</span><span class="mi">100</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)),</span> <span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>

<span class="c"># plot a spectrum of the cleaned ZAP dataproduct</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">zobj</span><span class="o">.</span><span class="n">cleancube</span><span class="p">[:,</span><span class="mi">50</span><span class="p">:</span><span class="mi">100</span><span class="p">,</span><span class="mi">50</span><span class="p">:</span><span class="mi">100</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)),</span> <span class="s">&#39;g&#39;</span><span class="p">)</span>

<span class="c"># choose just the first 3 spectra for all segmments</span>
<span class="n">zobj</span><span class="o">.</span><span class="n">reprocess</span><span class="p">(</span><span class="n">nevals</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

<span class="c"># plot a spectrum extracted from the original cube</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">zobj</span><span class="o">.</span><span class="n">cube</span><span class="p">[:,</span><span class="mi">50</span><span class="p">:</span><span class="mi">100</span><span class="p">,</span><span class="mi">50</span><span class="p">:</span><span class="mi">100</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)),</span> <span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>

<span class="c"># plot a spectrum of the cleaned ZAP dataproduct</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">zobj</span><span class="o">.</span><span class="n">cleancube</span><span class="p">[:,</span><span class="mi">50</span><span class="p">:</span><span class="mi">100</span><span class="p">,</span><span class="mi">50</span><span class="p">:</span><span class="mi">100</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))),</span> <span class="s">&#39;g&#39;</span><span class="p">)</span>

<span class="c"># choose some number of modes by hand</span>
<span class="n">zobj</span><span class="o">.</span><span class="n">reprocess</span><span class="p">(</span><span class="n">nevals</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>

<span class="c"># plot a spectrum</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">zobj</span><span class="o">.</span><span class="n">cleancube</span><span class="p">[:,</span><span class="mi">50</span><span class="p">:</span><span class="mi">100</span><span class="p">,</span><span class="mi">50</span><span class="p">:</span><span class="mi">100</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))),</span> <span class="s">&#39;k&#39;</span><span class="p">)</span>

<span class="c"># Use the optimization algorithm to identify the best number of modes per segment</span>
<span class="n">zobj</span><span class="o">.</span><span class="n">optimize</span><span class="p">()</span>

<span class="c"># compare to the previous versions</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">zobj</span><span class="o">.</span><span class="n">cleancube</span><span class="p">[:,</span><span class="mi">50</span><span class="p">:</span><span class="mi">100</span><span class="p">,</span><span class="mi">50</span><span class="p">:</span><span class="mi">100</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))),</span> <span class="s">&#39;r&#39;</span><span class="p">)</span>

<span class="c"># identify a pixel in the dispersion axis that shows a residual feature in the original</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">matshow</span><span class="p">(</span><span class="n">zobj</span><span class="o">.</span><span class="n">cube</span><span class="p">[</span><span class="mi">2903</span><span class="p">,:,:])</span>

<span class="c"># compare this to the zap dataproduct</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">matshow</span><span class="p">(</span><span class="n">zobj</span><span class="o">.</span><span class="n">cleancube</span><span class="p">[</span><span class="mi">2903</span><span class="p">,:,:])</span>

<span class="c"># write the processed cube as a single extension fits</span>
<span class="n">zobj</span><span class="o">.</span><span class="n">writecube</span><span class="p">(</span><span class="s">&#39;DATACUBE_ZAP.fits&#39;</span><span class="p">)</span>

<span class="c"># or merge the zap datacube into the original input datacube, replacing the data extension</span>
<span class="n">zobj</span><span class="o">.</span><span class="n">writefits</span><span class="p">(</span><span class="n">outcubefits</span><span class="o">=</span><span class="s">&#39;DATACUBE_FINAL_ZAP.fits&#39;</span><span class="p">)</span>
</pre></div>
</div>
<dl class="class">
<dt id="zap.zclass">
<em class="property">class </em><tt class="descclassname">zap.</tt><tt class="descname">zclass</tt><big>(</big><em>musecubefits</em><big>)</big><a class="headerlink" href="#zap.zclass" title="Permalink to this definition">¶</a></dt>
<dd><p>Main class to run each of the steps of ZAP.</p>
<p class="rubric">Attributes</p>
<table border="1" class="docutils">
<colgroup>
<col width="7%" />
<col width="93%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>cleancube</td>
<td>(numpy.ndarray) The final datacube after removing all of the residual features.</td>
</tr>
<tr class="row-even"><td>contarray</td>
<td>(numpy.ndarray) A 2D array containing the subtracted continuum per spaxel.</td>
</tr>
<tr class="row-odd"><td>cube</td>
<td>(numpy.ndarray) The original cube with the zlevel subtraction performed per spaxel.</td>
</tr>
<tr class="row-even"><td>especeval</td>
<td>(list of (eigenspectra, eval)) A list containing the full set of eigenspectra and eigenvalues generated by the SVD calculation that is used toy reconstruct the entire datacube.</td>
</tr>
<tr class="row-odd"><td>laxis</td>
<td>(numpy.ndarray) A 1d array containing the wavelength solution generated from the header parameters.</td>
</tr>
<tr class="row-even"><td>wcs</td>
<td>(astropy.wcs.WCS) WCS object with the wavelength solution.</td>
</tr>
<tr class="row-odd"><td>lranges</td>
<td>(list) A list of the wavelength bin limits used in segmenting the sepctrum for SVD.</td>
</tr>
<tr class="row-even"><td>nancube</td>
<td>(numpy.ndarray) A 3d boolean datacube containing True in voxels where a NaN value was replaced with an interpolation.</td>
</tr>
<tr class="row-odd"><td>nevals</td>
<td>(numpy.ndarray) A 1d array containing the number of eigenvalues used per segment to reconstruct the residuals.</td>
</tr>
<tr class="row-even"><td>normstack</td>
<td>(numpy.ndarray) A normalized version of the datacube decunstructed into a 2d array.</td>
</tr>
<tr class="row-odd"><td>varlist</td>
<td>(numpy.ndarray) An array for each segment with the variance curve, calculated for the optimize method.</td>
</tr>
<tr class="row-even"><td>pranges</td>
<td>(numpy.ndarray) The pixel indices of the bounding regions for each spectral segment.</td>
</tr>
<tr class="row-odd"><td>recon</td>
<td>(numpy.ndarray) A 2d array containing the reconstructed emission line residuals.</td>
</tr>
<tr class="row-even"><td>run_clean</td>
<td>(bool) Boolean that indicates that the NaN cleaning method was used.</td>
</tr>
<tr class="row-odd"><td>run_zlevel</td>
<td>(bool) Boolean indicating that the zero level correction was used.</td>
</tr>
<tr class="row-even"><td>stack</td>
<td>(numpy.ndarray) The datacube deconstructed into a 2d array for use in the the SVD.</td>
</tr>
<tr class="row-odd"><td>subespeceval</td>
<td>(list of (eigenspectra, eval)) The subset of eigenvalues and eigenspectra used to reconstruct the sky residuals.</td>
</tr>
<tr class="row-even"><td>variancearray</td>
<td>(numpy.ndarray) A list of length nsegments containing variances calculated per spaxel used for normalization</td>
</tr>
<tr class="row-odd"><td>y,x</td>
<td>(numpy.ndarray) The position in the cube of the spaxels that are in the 2d deconstructed stack</td>
</tr>
<tr class="row-even"><td>zlsky</td>
<td>(numpy.ndarray) A 1d array containing the result of the zero level subtraction</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">chooseevals</span></tt></td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">make_contcube</span></tt></td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">mergefits</span></tt></td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">optimize</span></tt></td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">plotvarcurve</span></tt></td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">reconstruct</span></tt></td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">remold</span></tt></td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">reprocess</span></tt></td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">writeSVD</span></tt></td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">writecube</span></tt></td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">writeskycube</span></tt></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="zap.zclass.chooseevals">
<tt class="descname">chooseevals</tt><big>(</big><em>nevals=[]</em>, <em>pevals=[]</em><big>)</big><a class="headerlink" href="#zap.zclass.chooseevals" title="Permalink to this definition">¶</a></dt>
<dd><p>Choose the number of eigenspectra/evals to use for reconstruction.</p>
<p>User supplies the number of eigen spectra to be used (neval) or the
percentage of the eigenspectra that were calculated (peval) from each
spectral segment to be used.</p>
<p>The user can either provide a single value to be used for all segments,
or provide an array that defines neval or peval per segment.</p>
</dd></dl>

<dl class="method">
<dt id="zap.zclass.make_contcube">
<tt class="descname">make_contcube</tt><big>(</big><big>)</big><a class="headerlink" href="#zap.zclass.make_contcube" title="Permalink to this definition">¶</a></dt>
<dd><p>Remold the continuum array so it can be investigated.</p>
<p>Takes the continuum stack and returns it into a familiar cube form.</p>
</dd></dl>

<dl class="method">
<dt id="zap.zclass.mergefits">
<tt class="descname">mergefits</tt><big>(</big><em>outcubefits</em><big>)</big><a class="headerlink" href="#zap.zclass.mergefits" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge the ZAP cube into the full muse datacube and write.</p>
</dd></dl>

<dl class="method">
<dt id="zap.zclass.optimize">
<tt class="descname">optimize</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#zap.zclass.optimize" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to optimize the number of components used to characterize
the residuals.</p>
<p>This function calculates the variance per segment with an increasing
number of eigenspectra/eigenvalues. It then deterimines the point at
which the second derivative of this variance curve reaches zero. When
this occurs, the linear reduction in variance is attributable to the
removal of astronomical features rather than emission line residuals.</p>
</dd></dl>

<dl class="method">
<dt id="zap.zclass.reconstruct">
<tt class="descname">reconstruct</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#zap.zclass.reconstruct" title="Permalink to this definition">¶</a></dt>
<dd><p>Reconstruct the residuals from a given set of eigenspectra and
eigenvalues</p>
</dd></dl>

<dl class="method">
<dt id="zap.zclass.remold">
<tt class="descname">remold</tt><big>(</big><big>)</big><a class="headerlink" href="#zap.zclass.remold" title="Permalink to this definition">¶</a></dt>
<dd><p>Subtracts the reconstructed residuals and places the cleaned
spectra into the duplicated datacube.</p>
</dd></dl>

<dl class="method">
<dt id="zap.zclass.reprocess">
<tt class="descname">reprocess</tt><big>(</big><em>pevals=[]</em>, <em>nevals=[]</em><big>)</big><a class="headerlink" href="#zap.zclass.reprocess" title="Permalink to this definition">¶</a></dt>
<dd><p>A method that redoes the eigenvalue selection, reconstruction, and
remolding of the data.</p>
</dd></dl>

<dl class="method">
<dt id="zap.zclass.writeSVD">
<tt class="descname">writeSVD</tt><big>(</big><em>svdoutputfits='ZAP_SVD.fits'</em><big>)</big><a class="headerlink" href="#zap.zclass.writeSVD" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the SVD to an individual fits file.</p>
</dd></dl>

<dl class="method">
<dt id="zap.zclass.writecube">
<tt class="descname">writecube</tt><big>(</big><em>outcubefits='DATACUBE_ZAP.fits'</em><big>)</big><a class="headerlink" href="#zap.zclass.writecube" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the processed datacube to an individual fits file.</p>
</dd></dl>

<dl class="method">
<dt id="zap.zclass.writeskycube">
<tt class="descname">writeskycube</tt><big>(</big><em>skycubefits='SKYCUBE_ZAP.fits'</em><big>)</big><a class="headerlink" href="#zap.zclass.writeskycube" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the processed datacube to an individual fits file.</p>
</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="#">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Welcome to ZAP&#8217;s documentation!</a></li>
<li><a class="reference internal" href="#installation">Installation</a><ul>
<li><a class="reference internal" href="#requirements">Requirements</a></li>
<li><a class="reference internal" href="#steps">Steps</a></li>
</ul>
</li>
<li><a class="reference internal" href="#examples">Examples</a><ul>
<li><a class="reference internal" href="#sparse-field-case">Sparse Field Case</a></li>
<li><a class="reference internal" href="#filled-field-case">Filled Field Case</a></li>
</ul>
</li>
<li><a class="reference internal" href="#extra-functions">Extra Functions</a></li>
<li><a class="reference internal" href="#command-line-interface">Command Line Interface</a></li>
<li><a class="reference internal" href="#interactive-mode">Interactive mode</a></li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/index.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li><a href="#">zap 1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014, Kurt Soto, Simon Lilly.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.3.
    </div>
  </body>
</html>