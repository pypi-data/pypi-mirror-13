# -*- coding: utf-8 -*-
"""
    aerate.falconapp
    ~~~~~~~~~~~~~~~~
    This module implements the central WSGI application object as a Falcon
    subclass.
    :copyright: (c) 2016 by Kelly Caylor.
    :license: BSD, see LICENSE for more details.
"""
from falcon import API
# from serve_swagger import SpecServer
from swagger import Swagger
import logging
logging.basicConfig(level=logging.INFO)
log = logging.getLogger(__name__)
from itertools import chain


class Aerate(API):

    def __init__(self, spec_file=None,
                 middleware=None,
                 operation_handlers=None,
                 config=None):
        API.__init__(self, middleware=middleware)
        self.resource_list = []
        self.operations = {}
        self.swagger = self.load_spec(spec_file=spec_file)
        # use Swagger object to build a swagger spec object.
        """
        Now that we have the swagger spec, we need to match each resource
        in the spec to a Resource in our falcon API. The list of resources
        we should be expecting can be defined in two ways:

            1) The list of swagger resources defined in the spec. This list is
            built by bravado_core based on item definitions in the schema.

            2) The list of faclon Resource classes defined in the API. This
            list can be built by parsing the list of operationIds generated by
            bravado_core,
                ASSUMING THE USER HAS CORRECTLY SPECIFIED THE OPERATION_IDs

            The Aerate format for OperationIds takes the form:
                <ResourceName><Collection | Item >_on_<http method>

            For example: PetCollection_on_get, UserItem_on_delete

        If we pass in a falcon Resource class, we can then make sure that all
        the OperationIds defined in the spec are also defined in the class. For
        now, we require that every OperationId defined in the spec is also
        defined in the class. Perhaps someday we can be cool about that.

        In addition, we need to make sure that any OperationIds that are
        associated with paths that contain params (e.g. '/user/{user_id}')
        have associated Resource responders that have the correct arguments.
        Using the example above, a path like '/user/{user_id}' with HTTP_METHOD
        get, would need the following responder:

        class UserItem(Resource):

            def on_get(self, req, resp, user_id)

        To check this conforms, if the swagger spec contains a parameter,
        we use the inspect.getargspec() function to ensure that the parameter
        is in the function.

        """
        # Make a single master list of all the OperationIds:
        op_id_list = []
        self.op_dict = {}
        for res in self.swagger.spec.resources.keys():
            op_id_list.append(dir(self.swagger.spec.resources[res]))

        # Flatten down the list of operationIds:
        self.op_ids_in_spec = list(chain.from_iterable(op_id_list))
        self.resource_list = list(
            set([x.split('_')[0] for x in self.op_ids_in_spec])
        )

        # for resource in self.swagger.spec.resources:
        #     self.add_resource(resource)

        # TODO: add routes based on the swagger spec instead of a sink.
        # TODO: would prefer to use a more robust swagger parsing/validation;
        #       possibly bravado-core by Yelp.
        # server = SpecServer(operation_handlers=operation_handlers)
        # with open(spec_file) as f:
        #     server.load_spec_swagger(f.read())

        # Main API routes are created as a sink.
        # self.add_sink(server, r'/')

    @staticmethod
    def load_spec(spec_file=None):

        if not spec_file:
            raise "ConfigError", "spec_file must be provided"
        if spec_file:
            swagger = Swagger()
            swagger.load_spec_from_file(spec_file)
        else:
            raise ValueError("spec_file must be provided")
        return swagger

    def _get_method_by_id(self, op_id):
        """
        Returns an API HTTP method correspoding to an OperationId defined
        defined in the swagger spec
        """
        return self.op_dict[op_id].http_method

    def _get_path_name_by_id(self, op_id):
        """
        Returns an API path correspoding to an OperationId
        defined in the swagger spec
        """
        return self.op_dict[op_id].path_name

    def add_resource(self, res):
        if res.name() not in self.resource_list:
            raise ValueError("{0} not in {1}".format(
                res.name(),
                self.resource_list))

        # Check to make sure defined methods match the OperationIds
        # for this resource:
        error_msg = "Swagger OperationId {0} not found in {1}"
        for op_id in res.valid_operationIds():
            if op_id not in self.op_ids_in_spec:
                raise ValueError(error_msg.format(op_id, res))
            # Grab the correct swagger operation based on this op_id
            op = self.swagger._get_op_by_id(op_id)
            # Only add this route if the route function passes validation:
            if res._validate_function_args(op):
                self.op_dict[op_id] = op
                # Let's just add this route for now...
                self.add_route(
                    self._get_path_name_by_id(op_id),
                    res)
            else:
                raise ValueError('Error validating {0} in {1}'.format(
                    op_id, res.name()))

        # TODO: Make sure that there are no Resource operations that don't
        # have corresponding Swagger specs.

        # if resource_name not in self.swagger.spec.resources.keys():
        #     raise 'ConfigError', "{0} not in {1}".format(
        #         resource_name, self.swagger.spec.resources.keys())
        # else:
        #     this_resource = self.swagger.spec.resources[resource_name]
        #     self.resources.append(this_resource)
        #     for operation in dir(this_resource):
        #         for method in ['on_get', 'on_post', 'on_delete', 'on_put']:
        #             op = getattr(resource_object, method, None)
        #             if op:
        #                 op_id = res + '_' + method
        #                 self.operations[op_id] = op
