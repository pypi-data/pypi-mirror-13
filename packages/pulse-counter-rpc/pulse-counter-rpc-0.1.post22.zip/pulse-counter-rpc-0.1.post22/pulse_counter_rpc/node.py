
# ############################################################################
# [2015-12-23 16:20:41.583000] THIS FILE IS AUTOGENERATED - DO NOT EDIT!
# ############################################################################
import types
import pandas as pd
import numpy as np
from nadamq.NadaMq import cPacket, PACKET_TYPES
from arduino_rpc.proxy import ProxyBase
try:
    from google.protobuf.message import Message
    _translate = (lambda arg: arg.SerializeToString()
                  if isinstance(arg, Message) else arg)
except ImportError:
    _translate = lambda arg: arg



from base_node_rpc.proxy import ProxyBase, I2cProxyMixin, SerialProxyMixin



class Proxy(ProxyBase):


    _CMD_BASE_NODE_SOFTWARE_VERSION = 0x00
    _CMD_PACKAGE_NAME = 0x01
    _CMD_DISPLAY_NAME = 0x02
    _CMD_MANUFACTURER = 0x03
    _CMD_SOFTWARE_VERSION = 0x04
    _CMD_URL = 0x05
    _CMD_MICROSECONDS = 0x06
    _CMD_MILLISECONDS = 0x07
    _CMD_DELAY_US = 0x08
    _CMD_DELAY_MS = 0x09
    _CMD_RAM_FREE = 0x0a
    _CMD_PIN_MODE = 0x0b
    _CMD_DIGITAL_READ = 0x0c
    _CMD_DIGITAL_WRITE = 0x0d
    _CMD_ANALOG_READ = 0x0e
    _CMD_ANALOG_WRITE = 0x0f
    _CMD_ARRAY_LENGTH = 0x10
    _CMD_ECHO_ARRAY = 0x11
    _CMD_STR_ECHO = 0x12
    _CMD_MAX_SERIAL_PAYLOAD_SIZE = 0xff
    _CMD_UPDATE_EEPROM_BLOCK = 0x1fe
    _CMD_READ_EEPROM_BLOCK = 0x1ff
    _CMD_EEPROM_E2END = 0x200
    _CMD_I2C_ADDRESS = 0x2fe
    _CMD_I2C_BUFFER_SIZE = 0x2ff
    _CMD_I2C_SCAN = 0x300
    _CMD_I2C_AVAILABLE = 0x301
    _CMD_I2C_READ_BYTE = 0x302
    _CMD_I2C_REQUEST_FROM = 0x303
    _CMD_I2C_READ = 0x304
    _CMD_I2C_WRITE = 0x305
    _CMD_I2C_ENABLE_BROADCAST = 0x306
    _CMD_I2C_DISABLE_BROADCAST = 0x307
    _CMD_MAX_I2C_PAYLOAD_SIZE = 0x3fc
    _CMD_I2C_REQUEST = 0x3fd
    _CMD_I2C_PACKET_RESET = 0x3fe
    _CMD_LOAD_CONFIG = 0x4fb
    _CMD_SAVE_CONFIG = 0x4fc
    _CMD_RESET_CONFIG = 0x4fd
    _CMD_SERIALIZE_CONFIG = 0x4fe
    _CMD_UPDATE_CONFIG = 0x4ff
    _CMD_ON_CONFIG_SERIAL_NUMBER_CHANGED = 0x500
    _CMD_ON_CONFIG_BAUD_RATE_CHANGED = 0x501
    _CMD_ON_CONFIG_I2C_ADDRESS_CHANGED = 0x502
    _CMD_RESET_STATE = 0x5fa
    _CMD_SERIALIZE_STATE = 0x5fb
    _CMD_UPDATE_STATE = 0x5fc
    _CMD_GET_BUFFER = 0x6f9
    _CMD_BEGIN = 0x6fa
    _CMD_SET_I2C_ADDRESS = 0x6fb
    _CMD_LOOP = 0x6fc
    _CMD_ON_CONFIG_MUX_CHANNEL_A_PIN_CHANGED = 0x6fd
    _CMD_ON_CONFIG_MUX_CHANNEL_B_PIN_CHANGED = 0x6fe
    _CMD_ON_STATE_PULSE_PIN_CHANGED = 0x6ff
    _CMD_ON_STATE_PULSE_DIRECTION_CHANGED = 0x700
    _CMD_ON_STATE_PULSE_CHANNEL_CHANGED = 0x701
    _CMD_SET_PULSE_PIN = 0x702
    _CMD_COUNT_PULSES = 0x703
    _CMD_START_PULSE_COUNT = 0x704
    _CMD_STOP_PULSE_COUNT = 0x705
    MAX_COMMAND_CODE = 1797


    def base_node_software_version(self):
        command = np.dtype('uint16').type(self._CMD_BASE_NODE_SOFTWARE_VERSION)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is an array, so return entire array.
        return result


    def package_name(self):
        command = np.dtype('uint16').type(self._CMD_PACKAGE_NAME)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is an array, so return entire array.
        return result


    def display_name(self):
        command = np.dtype('uint16').type(self._CMD_DISPLAY_NAME)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is an array, so return entire array.
        return result


    def manufacturer(self):
        command = np.dtype('uint16').type(self._CMD_MANUFACTURER)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is an array, so return entire array.
        return result


    def software_version(self):
        command = np.dtype('uint16').type(self._CMD_SOFTWARE_VERSION)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is an array, so return entire array.
        return result


    def url(self):
        command = np.dtype('uint16').type(self._CMD_URL)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is an array, so return entire array.
        return result


    def microseconds(self):
        command = np.dtype('uint16').type(self._CMD_MICROSECONDS)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint32')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def milliseconds(self):
        command = np.dtype('uint16').type(self._CMD_MILLISECONDS)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint32')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def delay_us(self, us):
        command = np.dtype('uint16').type(self._CMD_DELAY_US)
        ARG_STRUCT_SIZE = 2
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(us, )],
                               dtype=[('us', 'uint16'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def delay_ms(self, ms):
        command = np.dtype('uint16').type(self._CMD_DELAY_MS)
        ARG_STRUCT_SIZE = 2
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(ms, )],
                               dtype=[('ms', 'uint16'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def ram_free(self):
        command = np.dtype('uint16').type(self._CMD_RAM_FREE)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint32')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def pin_mode(self, pin, mode):
        command = np.dtype('uint16').type(self._CMD_PIN_MODE)
        ARG_STRUCT_SIZE = 2
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(pin, mode, )],
                               dtype=[('pin', 'uint8'), ('mode', 'uint8'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def digital_read(self, pin):
        command = np.dtype('uint16').type(self._CMD_DIGITAL_READ)
        ARG_STRUCT_SIZE = 1
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(pin, )],
                               dtype=[('pin', 'uint8'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def digital_write(self, pin, value):
        command = np.dtype('uint16').type(self._CMD_DIGITAL_WRITE)
        ARG_STRUCT_SIZE = 2
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(pin, value, )],
                               dtype=[('pin', 'uint8'), ('value', 'uint8'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def analog_read(self, pin):
        command = np.dtype('uint16').type(self._CMD_ANALOG_READ)
        ARG_STRUCT_SIZE = 1
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(pin, )],
                               dtype=[('pin', 'uint8'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint16')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def analog_write(self, pin, value):
        command = np.dtype('uint16').type(self._CMD_ANALOG_WRITE)
        ARG_STRUCT_SIZE = 2
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(pin, value, )],
                               dtype=[('pin', 'uint8'), ('value', 'uint8'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def array_length(self, array):
        command = np.dtype('uint16').type(self._CMD_ARRAY_LENGTH)
        ARG_STRUCT_SIZE = 6

        array = _translate(array)
        if isinstance(array, str):
            array = map(ord, array)
        # Argument is an array, so cast to appropriate array type.
        array = np.ascontiguousarray(array, dtype='uint8')
        array_info = pd.DataFrame([array.shape[0], ],
                                  index=['array', ],
                                  columns=['length'])
        array_info['start'] = array_info.length.cumsum() - array_info.length
        array_data = ''.join([array.tostring(), ])
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(array_info.length['array'], ARG_STRUCT_SIZE + array_info.start['array'], )],
                               dtype=[('array_length', 'uint32'), ('array_data', 'uint16'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint16')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def echo_array(self, array):
        command = np.dtype('uint16').type(self._CMD_ECHO_ARRAY)
        ARG_STRUCT_SIZE = 6

        array = _translate(array)
        if isinstance(array, str):
            array = map(ord, array)
        # Argument is an array, so cast to appropriate array type.
        array = np.ascontiguousarray(array, dtype='uint32')
        array_info = pd.DataFrame([array.shape[0], ],
                                  index=['array', ],
                                  columns=['length'])
        array_info['start'] = array_info.length.cumsum() - array_info.length
        array_data = ''.join([array.tostring(), ])
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(array_info.length['array'], ARG_STRUCT_SIZE + array_info.start['array'], )],
                               dtype=[('array_length', 'uint32'), ('array_data', 'uint16'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint32')

        # Return type is an array, so return entire array.
        return result


    def str_echo(self, msg):
        command = np.dtype('uint16').type(self._CMD_STR_ECHO)
        ARG_STRUCT_SIZE = 6

        msg = _translate(msg)
        if isinstance(msg, str):
            msg = map(ord, msg)
        # Argument is an array, so cast to appropriate array type.
        msg = np.ascontiguousarray(msg, dtype='uint8')
        array_info = pd.DataFrame([msg.shape[0], ],
                                  index=['msg', ],
                                  columns=['length'])
        array_info['start'] = array_info.length.cumsum() - array_info.length
        array_data = ''.join([msg.tostring(), ])
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(array_info.length['msg'], ARG_STRUCT_SIZE + array_info.start['msg'], )],
                               dtype=[('msg_length', 'uint32'), ('msg_data', 'uint16'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is an array, so return entire array.
        return result


    def max_serial_payload_size(self):
        command = np.dtype('uint16').type(self._CMD_MAX_SERIAL_PAYLOAD_SIZE)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='int32')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def update_eeprom_block(self, address, data):
        command = np.dtype('uint16').type(self._CMD_UPDATE_EEPROM_BLOCK)
        ARG_STRUCT_SIZE = 8

        data = _translate(data)
        if isinstance(data, str):
            data = map(ord, data)
        # Argument is an array, so cast to appropriate array type.
        data = np.ascontiguousarray(data, dtype='uint8')
        array_info = pd.DataFrame([data.shape[0], ],
                                  index=['data', ],
                                  columns=['length'])
        array_info['start'] = array_info.length.cumsum() - array_info.length
        array_data = ''.join([data.tostring(), ])
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(address, array_info.length['data'], ARG_STRUCT_SIZE + array_info.start['data'], )],
                               dtype=[('address', 'uint16'), ('data_length', 'uint32'), ('data_data', 'uint16'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def read_eeprom_block(self, address, n):
        command = np.dtype('uint16').type(self._CMD_READ_EEPROM_BLOCK)
        ARG_STRUCT_SIZE = 4
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(address, n, )],
                               dtype=[('address', 'uint16'), ('n', 'uint16'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is an array, so return entire array.
        return result


    def eeprom_e2end(self):
        command = np.dtype('uint16').type(self._CMD_EEPROM_E2END)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint32')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def i2c_address(self):
        command = np.dtype('uint16').type(self._CMD_I2C_ADDRESS)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def i2c_buffer_size(self):
        command = np.dtype('uint16').type(self._CMD_I2C_BUFFER_SIZE)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint16')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def i2c_scan(self):
        command = np.dtype('uint16').type(self._CMD_I2C_SCAN)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is an array, so return entire array.
        return result


    def i2c_available(self):
        command = np.dtype('uint16').type(self._CMD_I2C_AVAILABLE)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='int16')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def i2c_read_byte(self):
        command = np.dtype('uint16').type(self._CMD_I2C_READ_BYTE)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='int8')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def i2c_request_from(self, address, n_bytes_to_read):
        command = np.dtype('uint16').type(self._CMD_I2C_REQUEST_FROM)
        ARG_STRUCT_SIZE = 2
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(address, n_bytes_to_read, )],
                               dtype=[('address', 'uint8'), ('n_bytes_to_read', 'uint8'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='int8')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def i2c_read(self, address, n_bytes_to_read):
        command = np.dtype('uint16').type(self._CMD_I2C_READ)
        ARG_STRUCT_SIZE = 2
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(address, n_bytes_to_read, )],
                               dtype=[('address', 'uint8'), ('n_bytes_to_read', 'uint8'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is an array, so return entire array.
        return result


    def i2c_write(self, address, data):
        command = np.dtype('uint16').type(self._CMD_I2C_WRITE)
        ARG_STRUCT_SIZE = 7

        data = _translate(data)
        if isinstance(data, str):
            data = map(ord, data)
        # Argument is an array, so cast to appropriate array type.
        data = np.ascontiguousarray(data, dtype='uint8')
        array_info = pd.DataFrame([data.shape[0], ],
                                  index=['data', ],
                                  columns=['length'])
        array_info['start'] = array_info.length.cumsum() - array_info.length
        array_data = ''.join([data.tostring(), ])
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(address, array_info.length['data'], ARG_STRUCT_SIZE + array_info.start['data'], )],
                               dtype=[('address', 'uint8'), ('data_length', 'uint32'), ('data_data', 'uint16'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def i2c_enable_broadcast(self):
        command = np.dtype('uint16').type(self._CMD_I2C_ENABLE_BROADCAST)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def i2c_disable_broadcast(self):
        command = np.dtype('uint16').type(self._CMD_I2C_DISABLE_BROADCAST)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def max_i2c_payload_size(self):
        command = np.dtype('uint16').type(self._CMD_MAX_I2C_PAYLOAD_SIZE)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint32')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def i2c_request(self, address, data):
        command = np.dtype('uint16').type(self._CMD_I2C_REQUEST)
        ARG_STRUCT_SIZE = 7

        data = _translate(data)
        if isinstance(data, str):
            data = map(ord, data)
        # Argument is an array, so cast to appropriate array type.
        data = np.ascontiguousarray(data, dtype='uint8')
        array_info = pd.DataFrame([data.shape[0], ],
                                  index=['data', ],
                                  columns=['length'])
        array_info['start'] = array_info.length.cumsum() - array_info.length
        array_data = ''.join([data.tostring(), ])
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(address, array_info.length['data'], ARG_STRUCT_SIZE + array_info.start['data'], )],
                               dtype=[('address', 'uint8'), ('data_length', 'uint32'), ('data_data', 'uint16'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is an array, so return entire array.
        return result


    def i2c_packet_reset(self):
        command = np.dtype('uint16').type(self._CMD_I2C_PACKET_RESET)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def load_config(self):
        command = np.dtype('uint16').type(self._CMD_LOAD_CONFIG)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def save_config(self):
        command = np.dtype('uint16').type(self._CMD_SAVE_CONFIG)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def reset_config(self):
        command = np.dtype('uint16').type(self._CMD_RESET_CONFIG)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def serialize_config(self):
        command = np.dtype('uint16').type(self._CMD_SERIALIZE_CONFIG)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is an array, so return entire array.
        return result


    def update_config(self, serialized):
        command = np.dtype('uint16').type(self._CMD_UPDATE_CONFIG)
        ARG_STRUCT_SIZE = 6

        serialized = _translate(serialized)
        if isinstance(serialized, str):
            serialized = map(ord, serialized)
        # Argument is an array, so cast to appropriate array type.
        serialized = np.ascontiguousarray(serialized, dtype='uint8')
        array_info = pd.DataFrame([serialized.shape[0], ],
                                  index=['serialized', ],
                                  columns=['length'])
        array_info['start'] = array_info.length.cumsum() - array_info.length
        array_data = ''.join([serialized.tostring(), ])
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(array_info.length['serialized'], ARG_STRUCT_SIZE + array_info.start['serialized'], )],
                               dtype=[('serialized_length', 'uint32'), ('serialized_data', 'uint16'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def on_config_serial_number_changed(self, new_value):
        command = np.dtype('uint16').type(self._CMD_ON_CONFIG_SERIAL_NUMBER_CHANGED)
        ARG_STRUCT_SIZE = 4
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(new_value, )],
                               dtype=[('new_value', 'uint32'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def on_config_baud_rate_changed(self, new_value):
        command = np.dtype('uint16').type(self._CMD_ON_CONFIG_BAUD_RATE_CHANGED)
        ARG_STRUCT_SIZE = 4
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(new_value, )],
                               dtype=[('new_value', 'uint32'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def on_config_i2c_address_changed(self, new_value):
        command = np.dtype('uint16').type(self._CMD_ON_CONFIG_I2C_ADDRESS_CHANGED)
        ARG_STRUCT_SIZE = 4
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(new_value, )],
                               dtype=[('new_value', 'uint32'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def reset_state(self):
        command = np.dtype('uint16').type(self._CMD_RESET_STATE)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def serialize_state(self):
        command = np.dtype('uint16').type(self._CMD_SERIALIZE_STATE)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is an array, so return entire array.
        return result


    def update_state(self, serialized):
        command = np.dtype('uint16').type(self._CMD_UPDATE_STATE)
        ARG_STRUCT_SIZE = 6

        serialized = _translate(serialized)
        if isinstance(serialized, str):
            serialized = map(ord, serialized)
        # Argument is an array, so cast to appropriate array type.
        serialized = np.ascontiguousarray(serialized, dtype='uint8')
        array_info = pd.DataFrame([serialized.shape[0], ],
                                  index=['serialized', ],
                                  columns=['length'])
        array_info['start'] = array_info.length.cumsum() - array_info.length
        array_data = ''.join([serialized.tostring(), ])
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(array_info.length['serialized'], ARG_STRUCT_SIZE + array_info.start['serialized'], )],
                               dtype=[('serialized_length', 'uint32'), ('serialized_data', 'uint16'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def get_buffer(self):
        command = np.dtype('uint16').type(self._CMD_GET_BUFFER)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is an array, so return entire array.
        return result


    def begin(self):
        command = np.dtype('uint16').type(self._CMD_BEGIN)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def set_i2c_address(self, value):
        command = np.dtype('uint16').type(self._CMD_SET_I2C_ADDRESS)
        ARG_STRUCT_SIZE = 1
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(value, )],
                               dtype=[('value', 'uint8'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def loop(self):
        command = np.dtype('uint16').type(self._CMD_LOOP)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def on_config_mux_channel_a_pin_changed(self, mux_channel_a_pin):
        command = np.dtype('uint16').type(self._CMD_ON_CONFIG_MUX_CHANNEL_A_PIN_CHANGED)
        ARG_STRUCT_SIZE = 4
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(mux_channel_a_pin, )],
                               dtype=[('mux_channel_a_pin', 'uint32'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def on_config_mux_channel_b_pin_changed(self, mux_channel_b_pin):
        command = np.dtype('uint16').type(self._CMD_ON_CONFIG_MUX_CHANNEL_B_PIN_CHANGED)
        ARG_STRUCT_SIZE = 4
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(mux_channel_b_pin, )],
                               dtype=[('mux_channel_b_pin', 'uint32'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def on_state_pulse_pin_changed(self, old_pulse_pin, pulse_pin):
        command = np.dtype('uint16').type(self._CMD_ON_STATE_PULSE_PIN_CHANGED)
        ARG_STRUCT_SIZE = 8
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(old_pulse_pin, pulse_pin, )],
                               dtype=[('old_pulse_pin', 'int32'), ('pulse_pin', 'int32'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def on_state_pulse_direction_changed(self):
        command = np.dtype('uint16').type(self._CMD_ON_STATE_PULSE_DIRECTION_CHANGED)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def on_state_pulse_channel_changed(self, pulse_channel):
        command = np.dtype('uint16').type(self._CMD_ON_STATE_PULSE_CHANNEL_CHANGED)
        ARG_STRUCT_SIZE = 4
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(pulse_channel, )],
                               dtype=[('pulse_channel', 'uint32'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint8')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def set_pulse_pin(self, pulse_pin):
        command = np.dtype('uint16').type(self._CMD_SET_PULSE_PIN)
        ARG_STRUCT_SIZE = 1
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(pulse_pin, )],
                               dtype=[('pulse_pin', 'uint8'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def count_pulses(self, duration_ms):
        command = np.dtype('uint16').type(self._CMD_COUNT_PULSES)
        ARG_STRUCT_SIZE = 4
        array_data = ''
        payload_size = ARG_STRUCT_SIZE + len(array_data)
        struct_data = np.array([(duration_ms, )],
                               dtype=[('duration_ms', 'uint32'), ])
        payload_data = struct_data.tostring() + array_data

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='int32')

        # Return type is a scalar, so return first entry in array.
        return result[0]


    def start_pulse_count(self):
        command = np.dtype('uint16').type(self._CMD_START_PULSE_COUNT)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)


    def stop_pulse_count(self):
        command = np.dtype('uint16').type(self._CMD_STOP_PULSE_COUNT)
        payload_size = 0
        payload_data = ''

        payload_data = command.tostring() + payload_data
        packet = cPacket(data=payload_data, type_=PACKET_TYPES.DATA)
        response = self._send_command(packet)

        result = np.fromstring(response.data(), dtype='uint32')

        # Return type is a scalar, so return first entry in array.
        return result[0]







class I2cProxy(I2cProxyMixin, Proxy):
    pass


class SerialProxy(SerialProxyMixin, Proxy):
    pass


